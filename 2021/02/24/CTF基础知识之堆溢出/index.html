<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="堆溢出本文章首先介绍堆的基本单位的结构（chunk），之后介绍了堆的分配和释放函数，通过一个实例分析了堆溢出漏洞的危害（DWORD　SHOOT），最后介绍了另外两种利用堆溢出的漏洞（Double　free和Unlink）">
<meta property="og:type" content="article">
<meta property="og:title" content="CTF基础知识之堆溢出">
<meta property="og:url" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/index.html">
<meta property="og:site_name" content="L1E6N0A2">
<meta property="og:description" content="堆溢出本文章首先介绍堆的基本单位的结构（chunk），之后介绍了堆的分配和释放函数，通过一个实例分析了堆溢出漏洞的危害（DWORD　SHOOT），最后介绍了另外两种利用堆溢出的漏洞（Double　free和Unlink）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a1.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a1.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a2.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a2.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a3.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a3.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a17.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a17.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a18.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a18.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a4.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a4.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a5.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a5.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a6.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a6.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a7.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a7.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a8.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a8.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a10.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a10.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a9.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a9.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a11.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a11.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a12.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a12.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a13.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a13.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a14.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a14.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a16.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a16.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a15.png">
<meta property="og:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog/blog/source_posts/CTF基础知识之堆溢出/a15.png">
<meta property="article:published_time" content="2021-02-24T01:42:07.000Z">
<meta property="article:modified_time" content="2021-03-19T12:27:00.975Z">
<meta property="article:author" content="lyj789">
<meta property="article:tag" content="CTF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a1.png">

<link rel="canonical" href="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CTF基础知识之堆溢出 | L1E6N0A2</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">L1E6N0A2</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">监督自己不断学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lyj789">
      <meta itemprop="description" content="快乐打工人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L1E6N0A2">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CTF基础知识之堆溢出
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 09:42:07" itemprop="dateCreated datePublished" datetime="2021-02-24T09:42:07+08:00">2021-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-19 20:27:00" itemprop="dateModified" datetime="2021-03-19T20:27:00+08:00">2021-03-19</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>本文章首先介绍堆的基本单位的结构（chunk），之后介绍了堆的分配和释放函数，通过一个实例分析了堆溢出漏洞的危害（DWORD　SHOOT），最后介绍了另外两种利用堆溢出的漏洞（Double　free和Unlink）</p>
<a id="more"></a>

<h3 id="1-堆的结构"><a href="#1-堆的结构" class="headerlink" title="1.堆的结构"></a>1.堆的结构</h3><p>堆的基本单位是chunk，堆从低地址向高地址，需要用户自己分配。</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a1.png" class title="a1">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a1.png" alt="1"></p>
<p><strong>堆、栈区别总结</strong>：</p>
<p>1.堆栈空间分配</p>
<p> ①栈（操作系统）：由<strong>操作系统自动</strong>分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p> ②堆（操作系统）： 一般由<strong>程序员</strong>分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
<p>2.堆栈缓存方式</p>
<p>①栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</p>
<p>②堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<p>3.堆栈数据结构区别</p>
<p>①堆（数据结构）：堆可以被看成是一棵树，如：堆排序。</p>
<p>②栈（数据结构）：一种先进后出的数据结构。</p>
<p><strong>chunk的结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个字段的具体的解释如下</p>
<ul>
<li><p><code>prev_size</code>, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。</p>
</li>
<li><p><code>size</code>，该 chunk 的大小，包括用户申请的大小和头部的大小。 该字段的低三个比特位对 chunk 的大小没有影响，是三个标志位，它们从高到低分别表示：（重点关注<code>PREV_INUSE</code>位）</p>
<ul>
<li><code>NON_MAIN_ARENA</code>，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li><code>IS_MAPPED</code>，记录当前 chunk 是否是由 mmap 分配的。</li>
<li><code>PREV_INUSE</code>，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li><p><code>fd,bk</code>， chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li><code>fd</code> 指向下一个（非物理相邻）空闲的 chunk</li>
<li><code>bk</code> 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><p><code>fd_nextsize,bk_nextsize</code>, 也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li><p><strong>fd_nextsize</strong> 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p>
</li>
<li><p><strong>bk_nextsize</strong> 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p>
<p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p>
</li>
</ul>
</li>
</ul>
<p>一个已经分配的 <code>chunk</code> 的样子如下。我们称前两个字段称为 <code>chunk header</code>，pre_size与size都是4字节数据。后面的部分称为 <code>user data</code>。每次 malloc 申请得到的内存指针，其实指向 <code>user data</code> 的起始处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 <code>prev_size</code> 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。这就是 chunk 中的空间复用。</p>
<p><strong>bin链的分类与构成</strong></p>
<p>堆块释放之后会添加到相应的bins中进行管理</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/96865321">https://blog.csdn.net/qq_41453285/article/details/96865321</a></p>
<p>根据bin链成员的大小不同，分为以下几类：</p>
<p>fast bin是单链表，其他都是双向链表</p>
<ul>
<li><p><strong>Fast bin</strong>：拥有10个元素的数组，用户存放每个fast chunk的头指针。fastbin是最多包含十个fast chunk的单向链表。主要是为了提高小内存的分配效率，对于size_sz为8B的平台，小于128B的chunk分配，首先会在fastbin中查找是否有所需大小的chunk存在。</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a2.png" class title="a2">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a2.png" alt="2"></p>
</li>
<li><p><strong>Unsorted bin</strong>：1个。是smallbin和largebin的cache，所有空闲的chunk在回收时都要先放到unsortbin中，分配是如果unsortbin中没有合适的chunk，就会把unsortbin中所有的chunk加入到所属的bin中，在从bin中分配出合适的chunk。</p>
</li>
<li><p><strong>Small bin</strong>：62个</p>
</li>
<li><p><strong>Large bin</strong>：63个</p>
</li>
</ul>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a3.png" class title="a3">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a3.png" alt="3"></p>
<h3 id="2-堆的分配与释放"><a href="#2-堆的分配与释放" class="headerlink" title="2. 堆的分配与释放"></a>2. 堆的分配与释放</h3><ul>
<li>分配：malloc函数</li>
<li>释放：free函数</li>
</ul>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a17.png" class title="a17">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a17.png" alt="17"></p>
<p>上图的情形是，当前chunk的上一chunk被free()释放，容易发现，当前chunk的PREV_ISUSE标志位置0，表示前一chunk已经被释放。</p>
<p>被释放的chunk中，原先data的位置的低地址处被填入两个指针，分别是fd和bk，分别表示前一个free chunk和后一个free  chunk的地址。这样所有通过free()释放的内存chunk会组成一个双向链表。也因此一个chunk最小长度为16字节：2个size和2个指针。</p>
<p>当一个chunk被释放时，还有一件事情要做，就是检查相邻chunk的是否处于释放状态，如果相邻chunk空闲的话，就会进行chunk合并操作。由于每个chunk中都存放了size信息，所以很容易就找到当前chunk前后chunk的状态。</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a18.png" class title="a18">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a18.png" alt="18"></p>
<h3 id="3-堆溢出漏洞利用"><a href="#3-堆溢出漏洞利用" class="headerlink" title="3. 堆溢出漏洞利用"></a>3. 堆溢出漏洞利用</h3><p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123; </span><br><span class="line">	HLOCAL h1, h2,h3,h4,h5,h6;</span><br><span class="line">	HANDLE hp;</span><br><span class="line">	hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	_asm <span class="keyword">int</span> <span class="number">3</span><span class="comment">//break the process</span></span><br><span class="line"></span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h1);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h3);</span><br><span class="line">	HeapFree(hp,<span class="number">0</span>,h5); </span><br><span class="line">	_asm <span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	</span><br><span class="line">	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>流程分析</strong></p>
<p>（1）程序首先创建了一个大小为 0x1000 的堆区，并从其中连续申请了 6 个大小为 8 字节的堆块（加上块首实际上是 16 字节），这应<br> （2）释放奇数次申请的堆块是为了防止堆块合并的发生。<br> （3）三次释放结束后，freelist[2]所标识的空表中应该链入了 3 个空闲堆块，它们依次是 h1、 h3、h5。<br> （4）再次申请 8 字节的堆块，应该从 freelist[2]所标识的空表中分配，这意味着第一个堆块 h1 被从空表中“拆下”。（下面解释）<br> （5）如果我们手动修改 h1 块首中的指针，应该能够观察到 DWORD SHOOT 的发生。</p>
<p><strong>分配</strong></p>
<p>ollydbg调试，在第一个断点处中断，即分配完成。发现pmemoey的值为00390688，该值是堆分配函数的返回值，代表的是块头下用户可用区域的开始地址，因此分配的第一个堆块的地址为0x00390680。查看该地址的值：</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a4.png" class title="a4">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a4.png" alt="4"></p>
<p>下图显示了分配的6个块，例如0x390680-0x390690是一个块（两行是一个块）。注意到出了堆结构外还有16字节（ABAB… 0000…）这是调试堆的特征，增加16字节数据防止程序溢出，分析时可忽略。</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a5.png" class title="a5">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a5.png" alt="5"></p>
<p><strong>释放</strong></p>
<p>接下来程序继续运行，释放三块h1,h3,h5，释放之后堆中内存值如下图，可以看出h1,h3,h5的fd和bk指针均发生了改变，不再是0。</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a6.png" class title="a6">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a6.png" alt="6"></p>
<p>将fd（向前指针），bk（向后指针）的值列出，可以看出h1,h3,h5形成了一条双向链表，链在freelist[2]，因为块大小是16比特，freelist[2]管理所有大小为16比特的空闲块。</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>Flag</th>
<th>向前指针</th>
<th>向后指针</th>
</tr>
</thead>
<tbody><tr>
<td>h1</td>
<td>1 占用态</td>
<td>0x003906c8 (h3)</td>
<td>0x00390198(Freelist[2])</td>
</tr>
<tr>
<td>h2</td>
<td>0 空闲态</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>h3</td>
<td>1 占用态</td>
<td>0x00390708 (h5)</td>
<td>0x00390688(h1)</td>
</tr>
<tr>
<td>h4</td>
<td>0 空闲态</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>h5</td>
<td>1 占用态</td>
<td>0x00390198(Freelist[2])</td>
<td>0x003906c8 (h3)</td>
</tr>
<tr>
<td>h6</td>
<td>0 空闲态</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody></table>
<p><strong>freelist</strong></p>
<p>0x00390680-0x00390730是分配的6个堆块，下面0x00390040开始是未分配的空堆，fd，bk的值相同，指向的是freelist[0]，根据上表可知0x00390198是freelist[2]的地址</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a7.png" class title="a7">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a7.png" alt="7"></p>
<p>freelist的值如下如图：除了 freelist[0]和 freelist[2]之外，所有的空表索引都为空（指向自身）</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a8.png" class title="a8">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a8.png" alt="8"></p>
<p><strong>再分配</strong></p>
<p>最后一次 8 字节的内存请求会把 freelist[2]的第一项（原来的 h1）分配出去，这意味着将第一个结点从双向链表中“卸下”。为什么是第一个而不是最后一个呢，因为unsortbin采用先进先出的原则，添加/取走bin链上的一个freechunk时，是通过bin头的bk指针所操作的。</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a10.png" class title="a10">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a10.png" alt="10"></p>
<p>由上图可以看出0x00390198处链接的第一个块是0x00390688，即h1。观察最后一次申请内存时h1前后向指针的变化 非常重要。未申请内存之前 h1处的前向指针指向h3，  后向指针指向指向freelist[2]。当h1被卸下后，h3的前向指针不变为h5-0x390708  ，后向指针变为freelist[2]-0x390198（<strong>也就是将原来h1的后向指针的值，写入（h1前向指针地址+0x04）的地址的相对应的值中）</strong></p>
<blockquote>
<p>？？？？：教程写的都是去掉左后一个h5，然后相当于将原来h5的前向指针的值，写入h5后向指针地址的相对应的值中</p>
<p>截图来看确实是去掉了h1，h1的fd,bk的值都被置为0</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a9.png" class title="a9">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a9.png" alt="9"></p>
</blockquote>
<p>如果在程序中修改上述的 h1的前向指针为一个合法地址的时候，h1的后向指针就会被写入这个合法的地址当中，那么应该能够观察到 DWORD SHOOT 现象。所以可以直接在调试器中手动将h1(0x00390688) 处的后向指针改为shellcode的地址，前向指针改为任意地址-0x04，可以是系统调用。当最后一个分配函数被调用后，这条指令执行后，shellcode 将会被写入目标地址。</p>
<p>上面的例子只是引发 DWORD SHOOT 的一种情况。堆块的分配、释放、合并操作都能引发 DWORD SHOOT（因为都涉及链表操作）。</p>
<p><strong>攻击失败分析</strong></p>
<p>DWORD SHOOT攻击需要利用一个正常的调用，以实现恶意代码的执行，一般是利用RtlEnterCriticalSection() 和RtLeaveCritcalSection()。每个进程的PEB 中都存放这一对线程同步函数指针，指向RtlEnterCriticalSection() 和RtLeaveCritcalSection(),并且在进程退出的时候会被ExitProcess()调用，如果能够通过DWORD SHOOT 修改这对指针中的任意一个，那么在程序退出的时候ExitProcess()将会被骗去执行我们的shellcode。由于PEB的位置始终不会变化，所以这对指针相对于peb的偏移之中不变，这使得开发通用的exploit成为可能。 </p>
<p>本次采用peb中线程同步函数的入口地址 即 PEB（进程环境块） RtlEnterCriticalSection()。ExitProcess()函数在程序退出的时候会调用临界区函数，但是调用方法独特，是通过线程环境块中偏移 0x20处存放的函数指针来间接完成的。也就是偏移 0x7ffdf020处存放的指向RtlEnterCriticalSection()的指针。在0x7ffdf024处存放着RtlCriticalSection()的指针。但是Windows XP SP2 之后改写了实现方法，对这种攻击进行了防护。微软不再使用固定的 PEB 基址 0x7FFDF000，而是使用具有一定随机性的基址，从而影响了 DWORD SHOOT 对 PEB 中函数的攻击，无法准确利用该地址进行攻击，这种防御措施称为PEB Random。因此该种攻击方式仅可以在windows2000版本下进行复现，存在一定的局限性。</p>
<p>此外微软也改写了操作双向链表的代码，在卸载 free list 中的堆块时更加小心。SP2 在进行删除操作时，提前验证堆块的完整性，以防止 DWORD SHOOT，称为Safe Unlink。</p>
<h3 id="4-其他堆溢出漏洞利用"><a href="#4-其他堆溢出漏洞利用" class="headerlink" title="4. 其他堆溢出漏洞利用"></a>4. 其他堆溢出漏洞利用</h3><p>常见漏洞</p>
<ul>
<li><p>堆溢出：chunk1的数据溢出到chunk2，典型的攻击方式就是DWORD SHOOT（上面已经详细介绍）利用漏洞获取一个可以任意写的chunk，修改下一个chunk的关键信息如chunk头中的信息，如果下一个chunk是free状态，还可以修改BK和FD字段进行攻击。</p>
</li>
<li><p>double free：在释放chunk之后，没有对chunk指针清零。对同一地址调用两次free（）。潜在导致对未知内存位置的修改。double free的原理其实和堆溢出的原理差不多，都是通过unlink这个双向链表删除的宏来利用的。只是double free需要由自己来伪造整个chunk并且欺骗操作系统。为了让系统进行unlink的操作，达到篡改指针的目的。但是一般的情况下，我们两次释放同一块内存会被操作系统给检测出来，怎么欺骗过操作系统才是最重要的。</p>
<p>分配两个 chunk， chunk1 和 chunk2，然后<code>free(chunk1);free(chunk2);free(chunk1)</code>，假设进入fastbin管理，结构如下图：</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a11.png" class title="a11">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a11.png" alt="11"></p>
<p>表头指向chunk1，chunk1指向chunk2，chunk2又指回chunk1。那么这时按照如下步骤：</p>
<ul>
<li>申请一个new chunk 1：</li>
</ul>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a12.png" class title="a12">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a12.png" alt="12"></p>
<ul>
<li><p>将new chunk 1的指针域修改为要修改的地址-0x10以上：</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a13.png" class title="a13">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a13.png" alt="13"></p>
</li>
<li><p>申请一个new chunk 2：</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a14.png" class title="a14">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a14.png" alt="14"></p>
</li>
<li><p>再申请一个new chunk 3（new chunk 3是和new chunk 1重合的）</p>
<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a16.png" class title="a16">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a16.png" alt="16"></p>
</li>
</ul>
<p>这时可以发现，fastbin链表已经指向了我们想要修改的地址了，只要再申请一个堆块就会申请到想要修改的地址，然后只要编辑这个堆块便可完成任意地址写。</p>
</li>
<li><p>unlink：低版本libc2.23以下存在。使得攻击者拥有可以在任意可读写地址进行读写的能力。</p>
<p><strong>原理概述</strong></p>
<p>当堆块free时，会检查相邻的后面的堆块，或者前面的堆块，是否空闲，如果空闲，那么需要进行堆块合并操作。空闲的堆块一般以双向链表的形式组织（fast  bin是单向链表，此攻击不适用），如果刚刚释放的堆块要与前面或者后面空闲的堆块进行合并操作，那么需要将前或后的堆块从双向链表中摘下来，合并成更大的堆块插入到unsort bin链表中。空闲堆块从（small bin)双向链表中摘下来的操作就是unlink。</p>
<p>首先需要两个相邻的堆块，其中一个堆块空闲，一个堆块占用，释放占用的堆块，引发两个堆块合并。正常的空闲堆块链接在空闲链表中，我们无法控制其中的fd和bk指针，所以方法是伪造一个空闲的堆块。</p>
<p><strong>伪造空闲堆块</strong>：libc判断相邻堆块空闲的方法是通过本堆块的size字段，size字段最后3位是标志位。其中最后一位如果为0，说明相邻的堆块是free的，为1说明正在使用。pre_size字段指明前一个堆块的起始位置。这两个字段可以判断相邻的后面堆块是否分配和堆块的位置。</p>
<p>ps. 如果系统还会判断这个相邻的堆块是否在某个未分配的链表中，那么unlink攻击便实现不了。因为如果相邻堆块在某个空闲链表中，那么就无法修改其中的bk和fd指针。所以我们需要利用一个分配的堆块，来伪造出一个空闲堆块。</p>
<p><strong>具体操作</strong>：</p>
<p>分配两个堆块，但不要过小，大于fastbin的限制。</p>
<blockquote>
<p>示意图：chunkA-&gt;chunkB</p>
<p>ChunkA = prev_size | chunksize&amp;flag | content</p>
<p>ChunkB = prev_size | chunkSize&amp;flag | content</p>
</blockquote>
<p>如果此时chunkA存在堆溢出漏洞，那么我们便可将精心构造的数据写入chunkB. 或者直接修改后面分配的堆块的头部，即pre_size和size字段，pre_size需要设置成前面分配的堆块的用户区大小，并且设置size字段最后一位标志位为0，表示chunkA伪造堆块是空闲的。</p>
<p>那么在我们free(chunkB)时，堆管理器就会将chunkB和我们的fakeChunk合并。这是unlink会摘除chunkA，因此chunkA的fd，bk需要被伪造。</p>
<p>相应的也可以通过堆溢出，构造chunkB为伪造的空闲堆块。</p>
<p>假设被覆盖后的chunk header相关数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) prev_size &#x3D; 一个偶数，这样其PREV_INUSE 位就是0 了，即表示前一个chunk为free。</span><br><span class="line">2) size &#x3D; -4</span><br><span class="line">3) fd &#x3D; target addr – 24；(后文统一简称为“free addr – 24”)</span><br><span class="line">4) bk &#x3D; shellcode的地址</span><br></pre></td></tr></table></figure>

<p>这时free（chunkA），记nextchunk为chunkB。从上面代码可以知道，它是通过将nextchunk +  nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位。在本例中，此时nextsize被我们设置为了-4，这样glibc malloc就会将next chunk的prev_size字段看做是next-next chunk的size字段，而我们已经将next  chunk的prev_size字段设置为了一个偶数，因此此时通过inuse_bit_at_offset宏获取到的nextinuse为0，即next chunk为free！既然next chunk为free，那么就需要进行和chunkA合并，所以就会调用unlink(nextchunk, bck,  fwd);函数，将chunkB取下。</p>
<p><strong>绕过glibc的安全防护</strong></p>
<p>unlink之前需要进行一些简单的检查，设伪空闲堆块的堆块头指针是p，那么需要检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;bk-&gt;fd&#x3D;&#x3D;p &amp;&amp; p-&gt;fd-&gt;bk&#x3D;&#x3D;p</span><br></pre></td></tr></table></figure>

<p>这个检查是可以欺骗的：fd的偏移是3个机器位数，bk的偏移是4个机器位数。即在64位机器上，fd是8*3=24字节，bk是8*4=32字节；进行以下构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd &#x3D; ptr - 3*size(int); bk &#x3D; ptr - 2*size(int) </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为，FD &#x3D; p--&gt;fd &#x3D; ptr - 24； BK &#x3D;  p--&gt;bk &#x3D; ptr - 16，</span><br><span class="line">所以，FD--&gt;bk &#x3D; FD + 3*8 &#x3D; ptr - 24 + 24 &#x3D; p，</span><br><span class="line">     BK--&gt;fd &#x3D; BK + 16 &#x3D;  ptr - 16 + 16 &#x3D; p.</span><br><span class="line">     </span><br><span class="line">FD-&gt;bk &#x3D; BK; &#x3D;&#x3D;&gt; p &#x3D; ptr-16</span><br><span class="line">BK-&gt;fd &#x3D; FD; &#x3D;&#x3D;&gt; p &#x3D; ptr-24</span><br><span class="line">			 &#x3D;&#x3D;&gt; p&#x3D;ptr - 3*size(int)</span><br><span class="line">			 即P 的指针指向了比自己低 12 的地址处</span><br></pre></td></tr></table></figure>

<p><strong>恶意代码的构造</strong></p>
<p>构造恶意的fd与bk实现攻击，根据上面chunkB的构造，关注fd和bk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD&#x3D;P-&gt;fd &#x3D; target addr -24</span><br><span class="line">BK&#x3D;P-&gt;bk &#x3D; shellcode起始地址</span><br><span class="line">FD-&gt;bk &#x3D; BK，即 *(target addr-24 + 24)&#x3D;BK&#x3D;shellcode起始地址</span><br><span class="line">BK-&gt;fd &#x3D; FD，即 *(shellcode起始地址 +16) &#x3D; FD &#x3D; target addr-24</span><br></pre></td></tr></table></figure>

<img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/a15.png" class title="a15">

<p><img src="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA/Blog\blog\source_posts\CTF基础知识之堆溢出\a15.png" alt="15"></p>
<p>（图中的12是32位系统下，4*3=12，与上文保持统一的话，12就是24）</p>
<p>这样，通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 shellcode起始地址 +16地址具有可写的权限。</p>
<p>比如说我们将 target addr 设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值shellcode处的代码。需要注意的是，shellcode+16 处的值被破坏了，需要想办法绕过.</p>
</li>
</ul>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/484926468136">https://www.jianshu.com/p/484926468136</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gm-201705/p/9901548.html">https://www.cnblogs.com/gm-201705/p/9901548.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26981039">https://zhuanlan.zhihu.com/p/26981039</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50287973/article/details/108438564">https://blog.csdn.net/weixin_50287973/article/details/108438564</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zh_explorer/article/details/80307005">https://blog.csdn.net/zh_explorer/article/details/80307005</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25201379/article/details/81545128">https://blog.csdn.net/qq_25201379/article/details/81545128</a></p>
<p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/2019/12/24/5e01fc2754796/">https://www.dazhuanlan.com/2019/12/24/5e01fc2754796/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/97613588">https://blog.csdn.net/qq_41453285/article/details/97613588</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Breeze_CAT/article/details/103788698">https://blog.csdn.net/Breeze_CAT/article/details/103788698</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CTF/" rel="tag"># CTF</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/21/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89so%E6%A8%A1%E5%9D%97%E4%B8%8ENDK/" rel="prev" title="安卓逆向学习（三）so模块与NDK">
      <i class="fa fa-chevron-left"></i> 安卓逆向学习（三）so模块与NDK
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/24/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/" rel="next" title="CTF基础知识之污点分析">
      CTF基础知识之污点分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="nav-number">1.</span> <span class="nav-text">堆溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">1.堆的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A0%86%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-number">1.2.</span> <span class="nav-text">2. 堆的分配与释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">3. 堆溢出漏洞利用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%85%B6%E4%BB%96%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">4. 其他堆溢出漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A"><span class="nav-number">1.4.1.</span> <span class="nav-text">参考资料：</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lyj789</p>
  <div class="site-description" itemprop="description">快乐打工人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lyj789</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">104k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:34</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
